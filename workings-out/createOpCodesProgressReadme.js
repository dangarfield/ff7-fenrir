const fs = require('fs-extra')
const path = require('path')
const _ = require('lodash')
const { split } = require('lodash')



const OPS_FOLDER = './kujata-data/metadata'
const OPS_README = './OPS_CODES_README.md'

const getCategories = async () => {
    return fs.readJson(path.join(OPS_FOLDER, 'op-categories.json'))
}
const getMetadata = async () => {
    return fs.readJson(path.join(OPS_FOLDER, 'op-metadata.json'))
}
const getOpUsage = async (opCode) => {
    const usagePath = path.join(OPS_FOLDER, 'op-code-usages', `${opCode}.json`)
    if (fs.existsSync(usagePath)) {
        return fs.readJson(usagePath)
    } else {
        return []
    }

}
const getCompletedOpCodes = async () => {
    const completedCodes = []
    const files = ['flow', 'control', 'assign', 'window', 'party', 'models', 'background', 'camera-media', 'misc']
    for (let j = 0; j < files.length; j++) {
        const file = files[j]
        let c = fs.readFileSync(`./app/field/field-op-codes-${file}.js`).toString()
        if (c.includes('export {')) {
            c = c.split('export {')
            c = c[1].replace('}', '').split(',')
            for (let i = 0; i < c.length; i++) {
                completedCodes.push(c[i].trim())
            }
        }

    }
    console.log('completedCodes', completedCodes)
    return completedCodes
}
const generateCategoryData = async () => {
    let categories = await getCategories()
    let metadata = await getMetadata()
    let completedOpCodes = await getCompletedOpCodes()
    for (let i = 0; i < categories.length; i++) {
        const category = categories[i]
        category.ops = []
        for (let j = 0; j < category.opCodes.length; j++) {
            const opCode = category.opCodes[j]
            const usage = await getOpUsage(opCode)
            const completionStatus = completedOpCodes.includes(metadata[opCode].shortName)
            category.ops.push({
                code: opCode,
                name: metadata[opCode].shortName,
                description: metadata[opCode].description,
                usage: usage.length,
                completionStatus: completionStatus
            })
        }
    }
    // console.log('categories', JSON.stringify(categories))
    return categories
}
const createReadmeCell = (op) => {
    if (!op) {
        return ''
    } else {
        let color = 'green'
        let status = 'COMPLETE'
        if (!op.completionStatus) {
            color = 'red'
            status = 'INCOMPLETE'
        }
        return `![Generic badge](https://img.shields.io/badge/${op.name}-${status}-${color}.svg)<br>${op.description}<br>Usage - ${op.usage}`
    }
}
const renderReadme = async (categories) => {
    let r = `# FF7 - Fenrir - Op Code Implementation Progress\n`

    r = r + `\nNote: This page is autogenerated\n`

    for (let i = 0; i < categories.length; i++) {
        const category = categories[i]
        // console.log('category', category.name)
        r = r + `\n\n## ${category.name}\n`
        const opChunks = _.chunk(category.ops, 6)
        // console.log('opChunks', opChunks.length)
        r = r + `|  |  |  |  |  |  |\n`
        r = r + `|:---:|:---:|:---:|:---:|:---:|:---:|\n`
        for (let j = 0; j < opChunks.length; j++) {
            const opChunk = opChunks[j]
            r = r + `| ${createReadmeCell(opChunk[0])} | ${createReadmeCell(opChunk[1])} | ${createReadmeCell(opChunk[2])} | ${createReadmeCell(opChunk[3])} | ${createReadmeCell(opChunk[4])} | ${createReadmeCell(opChunk[5])} |\n`
        }
    }
    await fs.writeFile(OPS_README, r)
}
const init = async () => {
    console.log('createOpCodesProgressReadme: START')
    const categories = await generateCategoryData()
    await renderReadme(categories)
    console.log('createOpCodesProgressReadme: END')
}

init()