const fs = require('fs-extra')
const path = require('path')
const _ = require('lodash')
const OPS_FOLDER = path.join(__dirname, '..', '..', 'kujata-data', 'metadata')
const OPS_README = path.join(
  __dirname,
  '..',
  'OPS_CODES_ACTION_SEQUENCE_README.md'
)
const ACTIONS_LOOP = path.join(
  __dirname,
  '..',
  'app',
  'battle',
  'battle-actions-op-actions.js'
)

const getCompletedOpCodes = async filePath => {
  const completedCodes = []
  let c = fs.readFileSync(filePath).toString()
  if (c.includes('export {')) {
    c = c.split('export {')
    c = c[1].replace('}', '').split(',')
    for (let i = 0; i < c.length; i++) {
      let name = c[i].trim()
      name = name.replace('TWO_', '2')
      name = name.replace('_', '!')
      completedCodes.push(name)
    }
  }
  // console.log('completedCodes', completedCodes)
  return completedCodes
}
const generateProgress = async () => {
  const metadata = fs.readJsonSync(
    path.join(OPS_FOLDER, 'action-sequence-metadata-op.json')
  )

  // Add usage
  // const usage = fs.readJsonSync(
  //   path.join(OPS_FOLDER, 'battle-camera-op-usage.json')
  // )
  // for (type of Object.keys(usage)) {
  //   for (const opHex of Object.keys(usage[type])) {
  //     const u = usage[type][opHex]
  //     const op = metadata[type].opCodes.find(op => op.shortName === opHex)
  //     // console.log('u', type, opHex, u, op)
  //     op.usage = u
  //   }
  // }
  // Add completion
  const actionsComplete = {
    type: 'actions',
    complete: await getCompletedOpCodes(ACTIONS_LOOP)
  }
  for (items of [actionsComplete]) {
    for (const opCode of items.complete) {
      // console.log('opCode', items.type, opCode)
      const op = metadata[items.type].opCodes.find(
        op => op.shortName === opCode
      )
      if (op) {
        op.complete = true
      }
    }
  }

  // console.log('metadata', JSON.stringify(metadata, null, 2))

  let total = metadata.actions.opCodes.length
  let totalComplete = actionsComplete.complete.length // console.log('total', total, totalComplete)
  return { metadata, total, totalComplete }
}
const createReadmeCell = op => {
  if (!op) {
    return ''
  } else {
    // if (!op.usage) {
    //   op.usage = { initial: 0, main: 0, victory: 0 }
    // }
    let color = 'green'
    let status = 'COMPLETE'
    if (!op.complete) {
      color = 'red'
      status = 'INCOMPLETE'
    }
    return `![Generic badge](https://img.shields.io/badge/${op.shortName}-${status}-${color}.svg)<br><code>${op.hex}</code><br>${op.description}`
  }
}
const renderReadme = async data => {
  const totalProgress = Object.values(data.metadata).reduce(
    (acc, { opCodes }) => ({
      completed: acc.completed + opCodes.filter(o => o.complete).length,
      total: acc.total + opCodes.length
    }),
    { completed: 0, total: 0 }
  )

  let r = `# FF7 - Fenrir - Battle Action Sequence Op Code Implementation Progress - ${Math.round(
    (100 * totalProgress.completed) / totalProgress.total
  )}%\n`

  r = r + `\nNote: This page is autogenerated\n`
  r =
    r +
    `\nTotal progress: ${totalProgress.completed} of ${totalProgress.total}\n`

  for (const categoryName of Object.keys(data.metadata)) {
    const category = data.metadata[categoryName]
    //   // console.log('category', category.name)
    r =
      r +
      `\n\n## ${category.name}\n${category.description} - Progress: ${
        category.opCodes.filter(o => o.complete).length
      } of ${category.opCodes.length}\n`
    const opChunks = _.chunk(category.opCodes, 6)
    // console.log('opChunks', opChunks.length)
    r = r + `|  |  |  |  |  |  |\n`
    r = r + `|:---:|:---:|:---:|:---:|:---:|:---:|\n`
    for (let j = 0; j < opChunks.length; j++) {
      const opChunk = opChunks[j]
      // console.log('opChunk', opChunk)
      r =
        r +
        `| ${createReadmeCell(opChunk[0])} | ${createReadmeCell(
          opChunk[1]
        )} | ${createReadmeCell(opChunk[2])} | ${createReadmeCell(
          opChunk[3]
        )} | ${createReadmeCell(opChunk[4])} | ${createReadmeCell(
          opChunk[5]
        )} |\n`
    }
  }
  await fs.writeFile(OPS_README, r)
}
const createActionSequenceOpProgressReadme = async () => {
  console.log('create-op-create-action-sequence-op-progress-readme: START')
  const data = await generateProgress()
  await renderReadme(data)
  console.log('create-op-create-action-sequence-op-progress-readme: END')
}

module.exports = {
  createActionSequenceOpProgressReadme
}
